// Generated by LiveScript 1.4.0
var ref$, sleep, merge, unpack, pack, getLogger, log, http, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;
ref$ = require('aea'), sleep = ref$.sleep, merge = ref$.merge, unpack = ref$.unpack, pack = ref$.pack, getLogger = ref$.getLogger;
log = console.log;
http = require('http');
out$.LongPolling = LongPolling;
function LongPolling(settings){
  this.settings = settings;
  this.content = {
    node: this.settings.id
  };
  this.events = {
    error: [],
    connect: [],
    disconnect: [],
    data: []
  };
  this.connected = false;
  this.connecting = false;
  this.retryCount = 0;
  this.retryInterval = 500;
  this.maxInterval = 5000;
}
LongPolling.prototype.on = function(event, callback){
  var ref$;
  return (ref$ = this.events)[event] = ref$[event].concat(callback);
};
LongPolling.prototype.trigger = function(name){
  var event, i$, x$, ref$, len$, results$ = [];
  event = slice$.call(arguments, 1);
  for (i$ = 0, len$ = (ref$ = this.events[name]).length; i$ < len$; ++i$) {
    x$ = ref$[i$];
    if (typeof x$ === 'function') {
      results$.push(x$.apply(this, event));
    }
  }
  return results$;
};
LongPolling.prototype.send = function(p1, p2, p3){
  /*
  
  ::send msg[, path], callback
  
  
  uses `path` if available, else it will try to use @settings.path.db/msg.id
  */
  var msg, callback, path, e;
  msg = p1;
  callback = p2;
  path = this.settings.path.db + "/" + msg._id;
  if (p3) {
    callback = p3;
    path = p2;
  }
  try {
    if (!this.connected) {
      throw 'you MUST connect first!';
    }
    return this.putRaw(msg, path, callback);
  } catch (e$) {
    e = e$;
    return this.commErr(e, callback);
  }
};
LongPolling.prototype.get = function(p1, p2, p3){
  /*
  
  ::get path[, query], callback
  
  */
  var path, callback, query, e;
  path = p1;
  callback = p2;
  query = {};
  if (p3) {
    callback = p3;
    query = p2;
  }
  log("path: ", path, "query: ", query);
  try {
    if (!this.connected) {
      throw 'You MUST connect first!';
    }
    return this.getRaw(path, query, callback);
  } catch (e$) {
    e = e$;
    return this.commErr(e, callback);
  }
};
LongPolling.prototype.getRaw = function(path, query, callback){
  var __, queryStr, key, value, fullPath, err;
  __ = this;
  try {
    queryStr = "?" + (function(){
      var ref$, results$ = [];
      for (key in ref$ = query) {
        value = ref$[key];
        results$.push(key + "=" + value);
      }
      return results$;
    }()).join("&");
    fullPath = path + queryStr;
    return sleep(0, function(){
      var options, chunks, req;
      options = {
        host: __.settings.host,
        port: __.settings.port,
        method: 'GET',
        path: fullPath
      };
      chunks = "";
      req = http.get(options, function(res){
        var endOfTransmission;
        res.on('data', function(data){
          return chunks += data;
        });
        res.on('error', function(){
          return log("res error: ", err);
        });
        endOfTransmission = function(){
          var e;
          try {
            return callback(null, unpack(chunks));
          } catch (e$) {
            e = e$;
            try {
              if (chunks.slice(0, 10) === "CANNOT GET") {
                throw "not found";
              }
              throw 'unknown message format';
            } catch (e$) {
              e = e$;
              return callback({
                exception: e,
                message: chunks
              }, null);
            }
          }
        };
        res.on('end', function(){
          return endOfTransmission();
        });
        return res.on('close', function(){
          return endOfTransmission();
        });
      });
      return req.on('error', function(err){
        return __.commErr(err, callback);
      });
    });
  } catch (e$) {
    err = e$;
    return __.commErr(err, callback);
  }
};
LongPolling.prototype.commErr = function(reason, callback){
  log("comm error happened: ", reason);
  callback(reason, null);
  if (this.connected) {
    this.trigger('error', reason);
    this.trigger('disconnect');
    this.connected = false;
  }
  if (!this.connecting) {
    return this.connect();
  }
};
LongPolling.prototype.putRaw = function(msg, path, callback){
  var __, err, content, contentStr, options, req;
  __ = this;
  try {
    if (msg._id === null) {
      throw '_id field missing';
    }
    if (!this.connected) {
      throw 'not connected';
    }
    err = false;
    content = merge(this.content, msg);
    contentStr = pack(content);
    options = {
      host: this.settings.host,
      port: this.settings.port,
      method: 'PUT',
      path: path,
      headers: {
        "Content-Type": "application/json",
        "Content-Length": contentStr.length
      }
    };
    req = http.request(options, function(res){
      res.on('data', function(data){
        var e;
        try {
          return callback(null, unpack(data));
        } catch (e$) {
          e = e$;
          return callback(e, null);
        }
      });
      res.on('error', function(){
        throw "RES.ON ERROR???";
      });
      return res.on('close', function(){});
    });
    req.on('error', function(err){
      return __.commErr(err, callback);
    });
    req.write(contentStr);
    return req.end();
  } catch (e$) {
    err = e$;
    return __.commErr(err, callback);
  }
};
LongPolling.prototype.connect = function(nextStep){
  var __, interval;
  __ = this;
  this.connecting = true;
  interval = this.retryCount * this.retryInterval;
  if (interval > this.maxInterval) {
    interval = this.maxInterval;
  }
  this.retryCount++;
  return sleep(interval, function(){
    return __.getRaw(__.settings.path.info, {
      hello: "world"
    }, function(err, data){
      var e;
      try {
        if (err) {
          throw "connection error";
        }
        /*
        if data.aktos is \Welcome
            # log "connected to aktos device server"
        else if data.couchdb is \Welcome
            # log "connected to CouchDB"
        else
            throw "unknown server!"
        */
        return sleep(0, function(){
          __.retryCount = 0;
          __.connected = true;
          __.connecting = false;
          __.receiveLoop();
          __.trigger('connect', data);
          if (typeof nextStep === 'function') {
            return nextStep();
          }
        });
      } catch (e$) {
        e = e$;
        console.log("LongPolling: Connect error : ", e);
        return sleep(10, function(){
          __.connecting = false;
          return __.connect();
        });
      }
    });
  });
};
LongPolling.prototype.receiveLoop = function(){
  var __;
  __ = this;
  return function lo(op){
    return __.getRaw(__.settings.path.changes, {
      since: 'now',
      feed: 'longpoll'
    }, function(err, res){
      if (err) {
        return op();
      } else {
        __.trigger('data', res);
        return lo(op);
      }
    });
  }(function(){});
};
