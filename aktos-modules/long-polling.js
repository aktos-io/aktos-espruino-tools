// Generated by LiveScript 1.5.0
var ref$, sleep, merge, unpack, pack, repl, config, http, getLogger, i, out$ = typeof exports != 'undefined' && exports || this;
ref$ = require('aea'), sleep = ref$.sleep, merge = ref$.merge, unpack = ref$.unpack, pack = ref$.pack, repl = ref$.repl, config = ref$.config;
http = require('http');
getLogger = function(){
  return console.log;
};
i = 0;
function LongPolling(settings){
  this.settings = settings;
  this.content = {
    node: this.settings.id
  };
  this.events = {
    error: [],
    connect: [],
    disconnect: [],
    data: []
  };
  this.connected = false;
  this.connecting = false;
  this.retryCount = 0;
  this.retryInterval = 500;
  this.maxInterval = 5000;
}
LongPolling.prototype.on = function(event, callback){
  var ref$;
  return (ref$ = this.events)[event] = ref$[event].concat(callback);
};
LongPolling.prototype.trigger = function(name){
  var event, res$, i$, to$, x$, ref$, len$, results$ = [];
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  event = res$;
  for (i$ = 0, len$ = (ref$ = this.events[name]).length; i$ < len$; ++i$) {
    x$ = ref$[i$];
    if (typeof x$ === 'function') {
      results$.push(x$.apply(this, event));
    }
  }
  return results$;
};
LongPolling.prototype.send = function(msg, callback){
  var log, e;
  log = getLogger('SEND');
  try {
    if (!this.connected) {
      throw 'you MUST connect first!';
    }
    return this.putRaw(msg, callback);
  } catch (e$) {
    e = e$;
    return this.commErr(e, callback);
  }
};
LongPolling.prototype.getRaw = function(){
  var i$, params, res$, j$, callback, query, path, __, log, queryStr, key, value, err;
  res$ = [];
  for (j$ = 0 < (i$ = arguments.length - 1) ? 0 : (i$ = 0); j$ < i$; ++j$) {
    res$.push(arguments[j$]);
  }
  params = res$; callback = arguments[i$];
  query = params[0], path = params[1];
  __ = this;
  log = getLogger('GET_RAW');
  if (!path) {
    path = this.settings.path.changes;
  }
  try {
    queryStr = "?" + (function(){
      var ref$, results$ = [];
      for (key in ref$ = query) {
        value = ref$[key];
        results$.push(key + "=" + value);
      }
      return results$;
    }()).join("&");
    return sleep(0, function(){
      var options, chunks, req;
      options = {
        host: __.settings.host,
        port: __.settings.port,
        method: 'GET',
        path: path + queryStr
      };
      chunks = "";
      req = http.get(options, function(res){
        res.on('data', function(data){
          return chunks += data;
        });
        res.on('error', function(){
          throw null;
        });
        res.on('end', function(){
          var e;
          try {
            return callback(null, unpack(chunks));
          } catch (e$) {
            e = e$;
            return callback({
              exception: e,
              message: chunks
            }, null);
          }
        });
        return res.on('close', function(){
          return callback(null, unpack(chunks));
        });
      });
      return req.on('error', function(err){
        return __.commErr(err, callback);
      });
    });
  } catch (e$) {
    err = e$;
    return __.commErr(err, callback);
  }
};
LongPolling.prototype.commErr = function(reason, callback){
  var log;
  log = getLogger('COMM_ERR');
  callback(reason, null);
  if (this.connected) {
    this.trigger('error', reason);
    this.trigger('disconnect');
    this.connected = false;
  }
  if (this.connecting) {
    return log("Already trying to reconnect!...");
  } else {
    return this.connect();
  }
};
LongPolling.prototype.putRaw = function(){
  var i$, params, res$, j$, callback, __, log, msg, path, e, err, content, contentStr, options, req;
  res$ = [];
  for (j$ = 0 < (i$ = arguments.length - 1) ? 0 : (i$ = 0); j$ < i$; ++j$) {
    res$.push(arguments[j$]);
  }
  params = res$; callback = arguments[i$];
  __ = this;
  log = getLogger("PUT_RAW");
  try {
    msg = params[0], path = params[1];
  } catch (e$) {
    e = e$;
    log("something went wrong: ", e);
  }
  try {
    if (msg._id === null) {
      throw 'documents must have and _id field';
    }
    if (!this.connected) {
      throw 'not connected';
    }
    path = this.settings.path.db + "/" + msg._id;
    err = false;
    content = merge(this.content, msg);
    contentStr = pack(content);
    options = {
      host: this.settings.host,
      port: this.settings.port,
      method: 'PUT',
      path: path,
      headers: {
        "Content-Type": "application/json",
        "Content-Length": contentStr.length
      }
    };
    req = http.request(options, function(res){
      res.on('data', function(data){
        var e;
        try {
          return callback(null, unpack(data));
        } catch (e$) {
          e = e$;
          return callback(e, null);
        }
      });
      res.on('error', function(){
        throw "RES.ON ERROR???";
      });
      return res.on('close', function(){});
    });
    req.on('error', function(err){
      return __.commErr(err, callback);
    });
    req.write(contentStr);
    return req.end();
  } catch (e$) {
    err = e$;
    return __.commErr(err, callback);
  }
};
LongPolling.prototype.connect = function(nextStep){
  var __, log, interval;
  __ = this;
  log = getLogger('CONNECT');
  this.connecting = true;
  interval = this.retryCount * this.retryInterval;
  if (interval > this.maxInterval) {
    interval = this.maxInterval;
  }
  this.retryCount++;
  return sleep(interval, function(){
    return __.getRaw({
      hello: "world",
      foo: "bar"
    }, __.settings.path.info, function(err, data){
      var e;
      try {
        if (err) {
          throw "connection error";
        }
        if (data.aktos === 'Welcome') {
          log("connected to aktos device server");
        } else if (data.couchdb === 'Welcome') {
          log("connected to CouchDB");
        } else {
          throw "unknown server!";
        }
        return sleep(0, function(){
          __.retryCount = 0;
          __.connected = true;
          __.connecting = false;
          __.receiveLoop();
          __.trigger('connect', data);
          if (typeof nextStep === 'function') {
            return nextStep();
          }
        });
      } catch (e$) {
        e = e$;
        return sleep(10, function(){
          __.connecting = false;
          return __.connect();
        });
      }
    });
  });
};
LongPolling.prototype.receiveLoop = function(){
  var __, log;
  __ = this;
  log = getLogger('RECEIVE_LOOP');
  return function lo(op){
    return __.getRaw({
      since: 'now',
      feed: "longpoll"
    }, __.settings.path.changes, function(err, res){
      if (err) {
        return op();
      } else {
        __.trigger('data', res);
        return lo(op);
      }
    });
  }(function(){});
};
out$.LongPolling = LongPolling;
